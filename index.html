<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>SnapMark - 画像編集ツール</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { sans: ['"Inter"', '"Noto Sans JP"', 'sans-serif'] },
                    colors: { 
                        brand: { 50: '#f0fdfa', 100: '#ccfbf1', 500: '#14b8a6', 600: '#0d9488', 700: '#0f766e', 900: '#134e4a' },
                        accent: { 500: '#6366f1', 600: '#4f46e5' }
                    },
                    boxShadow: { 
                        'glass': '0 8px 32px 0 rgba(31, 38, 135, 0.07)',
                        'float': '0 10px 40px -10px rgba(0,0,0,0.1)'
                    }
                }
            }
        }
    </script>
    <style>
        /* 100dvhでモバイルブラウザのアドレスバー変動に対応 */
        body { font-family: 'Inter', 'Noto Sans JP', sans-serif; touch-action: none; background-color: #f8fafc; color: #0f172a; height: 100dvh; overflow: hidden; }
        
        .custom-scrollbar::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 99px; border: 2px solid transparent; background-clip: content-box; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background-color: #94a3b8; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        /* ツールボタン */
        .tool-btn { position: relative; transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); border-radius: 12px; }
        .tool-btn.active { background-color: #0f172a; color: white; box-shadow: 0 4px 12px rgba(15, 23, 42, 0.15); transform: translateY(-1px); }
        .tool-btn:hover:not(.active) { background-color: #e2e8f0; transform: translateY(-1px); }

        /* ドラムロール */
        .drum-container { position: relative; height: 120px; overflow: hidden; background: #f8fafc; border-radius: 16px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.02); touch-action: pan-y; }
        .drum-mask { position: absolute; inset: 0; pointer-events: none; z-index: 10; background: linear-gradient(to bottom, #ffffff 0%, transparent 40%, transparent 60%, #ffffff 100%); }
        .drum-scroll { height: 100%; overflow-y: auto; scroll-snap-type: y mandatory; padding-top: 40px; padding-bottom: 40px; scrollbar-width: none; width: 100%; overflow-x: hidden; }
        .drum-item { height: 40px; display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: 500; color: #94a3b8; scroll-snap-align: center; transition: all 0.2s ease; cursor: pointer; width: 100%; }
        .drum-item.active { color: #0f172a; font-size: 24px; font-weight: 700; transform: scale(1.1); }
        .drum-highlight { position: absolute; top: 50%; left: 16px; right: 16px; height: 40px; transform: translateY(-50%); border-radius: 8px; background-color: rgba(15, 23, 42, 0.03); pointer-events: none; z-index: 0; }

        /* カスタムスライダー */
        input[type=range] { -webkit-appearance: none; background: transparent; cursor: pointer; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%; background: #ffffff; border: 2px solid #0f172a; margin-top: -8px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); transition: transform 0.1s; }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.15); }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; border-radius: 2px; background: linear-gradient(to right, #cbd5e1 0%, #cbd5e1 100%); }

        /* ピッカーパネル (Glassmorphism) */
        .glass-panel {
            background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.5); box-shadow: 0 10px 40px -10px rgba(0,0,0,0.15);
            /* スマホでの安全領域確保 */
            padding-bottom: calc(env(safe-area-inset-bottom) + 20px);
        }
        
        .panel-enter { animation: panel-in 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards; }
        @keyframes panel-in {
            from { opacity: 0; transform: translateY(20px) scale(0.96); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        /* カラーピッカー */
        .color-dot { width: 32px; height: 32px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); cursor: pointer; transition: transform 0.15s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .color-dot:hover { transform: scale(1.15); }
        .color-dot.active { box-shadow: 0 0 0 2px white, 0 0 0 4px #0f172a; z-index: 1; }
        .color-input-wrapper { position: relative; width: 100%; height: 40px; border-radius: 12px; overflow: hidden; cursor: pointer; border: 1px solid #e2e8f0; background: white; transition: border-color 0.2s; }
        .color-input-wrapper:hover { border-color: #cbd5e1; }
        input[type="color"] { position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; padding: 0; margin: 0; border: none; cursor: pointer; }

        /* トースト通知 */
        #toast {
            position: fixed; top: 32px; left: 50%; transform: translateX(-50%) translateY(-150%);
            opacity: 0; visibility: hidden; transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            z-index: 100; box-shadow: 0 10px 30px -10px rgba(0,0,0,0.15);
            background-color: #1f2937; color: white;
            padding: 12px 28px; border-radius: 99px;
            display: flex; align-items: center; gap: 12px;
        }
        #toast.show { transform: translateX(-50%) translateY(0); opacity: 1; visibility: visible; }
        
        .tool-separator { width: 1px; height: 24px; background-color: #e2e8f0; margin: 0 6px; }
        @media (max-width: 768px) { .tool-separator { width: 24px; height: 1px; margin: 6px 0; } }

        /* LP風デザイン */
        .lp-bg { background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); }
        .mesh-gradient { position: absolute; width: 100%; height: 100%; top: 0; left: 0; overflow: hidden; pointer-events: none; z-index: 0; }
        .mesh-blob { position: absolute; border-radius: 50%; filter: blur(80px); opacity: 0.6; }
        .step-card {
            background: rgba(255, 255, 255, 0.7); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 24px; padding: 28px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.01); transition: all 0.3s ease;
        }
        .step-card:hover { transform: translateY(-4px); background: rgba(255, 255, 255, 0.9); box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.08); }
        .step-icon-wrapper {
            width: 48px; height: 48px; border-radius: 16px; background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%);
            display: flex; align-items: center; justify-content: center; color: #4f46e5; margin-bottom: 16px;
        }
        .upload-area {
            background: rgba(255,255,255,0.6); backdrop-filter: blur(10px); border: 2px dashed #cbd5e1;
            border-radius: 32px; transition: all 0.3s ease; box-shadow: 0 10px 30px -10px rgba(0,0,0,0.05);
        }
        .upload-area:hover, .upload-area.drag-over { border-color: #4f46e5; background: rgba(238, 242, 255, 0.8); transform: scale(1.01); }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden bg-slate-50">

    <!-- ヘッダー -->
    <header class="bg-white/60 backdrop-blur-xl border-b border-white/20 z-30 shrink-0 h-16 sticky top-0 shadow-sm">
        <div class="max-w-[1600px] mx-auto px-6 h-full flex items-center justify-between">
            
            <div class="flex items-center gap-4">
                <!-- 戻るボタン: onclickでresetEditorを呼ぶ -->
                <button id="closeBtn" onclick="closeEditor()" class="hidden relative z-50 p-2 -ml-2 rounded-full text-slate-500 hover:bg-slate-100 hover:text-slate-900 transition-colors mr-1 cursor-pointer" title="編集を終了">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>

                <!-- ロゴ -->
                <div id="logoBtn" onclick="closeEditor()" class="flex items-center gap-3 select-none cursor-pointer group">
                    <div class="bg-gradient-to-br from-indigo-500 to-purple-600 text-white p-2 rounded-xl shadow-lg shadow-indigo-500/20 group-hover:scale-105 transition-transform duration-300">
                        <i data-lucide="pen-tool" class="w-5 h-5"></i>
                    </div>
                    <div class="hidden sm:block">
                        <h1 class="text-xl font-extrabold tracking-tight text-slate-800 leading-none">SnapMark</h1>
                    </div>
                </div>
            </div>

            <div class="flex items-center gap-3">
                <button onclick="document.getElementById('fileInput').click()" class="hidden md:flex items-center gap-2 px-5 py-2.5 rounded-full text-sm font-bold text-slate-600 hover:bg-slate-100 transition-all hover:shadow-inner">
                    <i data-lucide="image-plus" class="w-4 h-4"></i> 開く
                </button>
                <input type="file" id="fileInput" class="hidden" accept="image/*">
                <!-- スマホ用 開くボタン -->
                <button onclick="document.getElementById('fileInput').click()" class="md:hidden p-2 rounded-full text-slate-600 hover:bg-slate-100 transition-colors"><i data-lucide="image-plus" class="w-6 h-6"></i></button>

                <!-- 編集時のみ表示するボタン群 -->
                <div id="actionButtons" class="hidden flex items-center gap-3">
                    <div class="h-8 w-px bg-slate-200 mx-1 hidden md:block"></div>
                    <button onclick="saveImage()" class="flex items-center gap-2 px-6 py-2.5 bg-brand-600 text-white text-sm font-bold rounded-full hover:bg-brand-700 shadow-lg shadow-brand-600/25 transition-all active:scale-95 transform hover:-translate-y-0.5">
                        <i data-lucide="download" class="w-4 h-4"></i> <span>保存</span>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <div class="flex flex-1 flex-col-reverse md:flex-row overflow-hidden relative">
        
        <!-- サイドバー (編集時のみ表示) -->
        <!-- pb-[calc(env(safe-area-inset-bottom)+48px)] で下部を大幅に底上げしてSafariバー被り回避 -->
        <aside id="sidebar" class="hidden w-full md:w-[96px] bg-white/70 backdrop-blur-2xl border-t md:border-t-0 md:border-r border-white/20 md:flex-col z-20 shadow-xl shadow-slate-200/50 shrink-0 items-center justify-between md:justify-start py-3 md:py-8 px-4 md:px-0 gap-2 md:gap-6 overflow-x-auto no-scrollbar pb-[calc(env(safe-area-inset-bottom)+48px)] md:pb-6">
            
            <!-- メインツール -->
            <div class="flex md:flex-col gap-2 md:gap-4 items-center">
                <button onclick="setMode('select')" id="btn-select" class="tool-btn active w-12 h-12 flex items-center justify-center" title="選択 (V)">
                    <i data-lucide="mouse-pointer-2" class="w-6 h-6"></i>
                </button>
                
                <button onclick="setMode('rect')" id="btn-rect" class="tool-btn w-12 h-12 flex items-center justify-center text-slate-500" title="枠線 (R)">
                    <i data-lucide="square" class="w-6 h-6"></i>
                </button>
                <button onclick="setMode('arrow')" id="btn-arrow" class="tool-btn w-12 h-12 flex items-center justify-center text-slate-500" title="矢印 (A)">
                    <i data-lucide="arrow-up-right" class="w-6 h-6"></i>
                </button>
                <button onclick="setMode('text')" id="btn-text" class="tool-btn w-12 h-12 flex items-center justify-center text-slate-500" title="文字 (T)">
                    <i data-lucide="type" class="w-6 h-6"></i>
                </button>
                
                <button onclick="toggleSizePicker()" id="btn-size" class="tool-btn w-12 h-12 flex flex-col items-center justify-center gap-0.5 text-slate-500" title="サイズ設定">
                    <i data-lucide="sliders-horizontal" class="w-5 h-5"></i>
                </button>

                <button onclick="toggleColorPicker()" id="btn-color" class="tool-btn w-12 h-12 flex items-center justify-center relative hover:bg-white" title="色設定">
                    <div id="current-color-indicator" class="w-6 h-6 rounded-full border border-black/5 shadow-sm" style="background-color: #ef4444;"></div>
                </button>
            </div>

            <div class="tool-separator hidden md:block"></div>

            <!-- マスク & 削除 -->
            <div class="flex md:flex-col gap-2 md:gap-4 items-center">
                <button onclick="setMode('mask-black')" id="btn-mask-black" class="tool-btn w-12 h-12 flex items-center justify-center text-slate-500" title="塗りつぶし">
                    <div class="w-6 h-6 bg-slate-800 rounded-lg shadow-sm"></div>
                </button>
                <button onclick="setMode('mask-mosaic')" id="btn-mask-mosaic" class="tool-btn w-12 h-12 flex items-center justify-center text-slate-500" title="モザイク">
                    <i data-lucide="grip" class="w-6 h-6"></i>
                </button>
                
                <div class="tool-separator"></div>

                <button onclick="deleteObject()" class="w-12 h-12 flex items-center justify-center rounded-2xl bg-rose-50 text-rose-500 hover:bg-rose-100 hover:text-rose-600 transition-colors" title="削除 (Del)">
                    <i data-lucide="trash-2" class="w-6 h-6"></i>
                </button>
                <button onclick="resetCanvas()" class="w-12 h-12 flex items-center justify-center rounded-2xl text-slate-400 hover:bg-white hover:text-slate-600 transition-colors" title="全消去">
                    <i data-lucide="rotate-ccw" class="w-6 h-6"></i>
                </button>
            </div>
        </aside>

        <!-- メインエリア -->
        <main class="flex-1 relative flex flex-col overflow-hidden">
            
            <!-- LP風 初期画面 -->
            <div id="emptyState" class="absolute inset-0 z-20 flex flex-col items-center overflow-auto custom-scrollbar lp-bg">
                <div class="mesh-gradient">
                    <div class="mesh-blob bg-blue-400 w-96 h-96 top-0 left-0 animate-blob"></div>
                    <div class="mesh-blob bg-purple-400 w-96 h-96 bottom-0 right-0 animate-blob" style="animation-delay: -5s; animation-direction: reverse;"></div>
                    <div class="mesh-blob bg-pink-300 w-64 h-64 bottom-[20%] left-[20%] animate-blob" style="animation-delay: -2s;"></div>
                </div>

                <div class="max-w-5xl w-full text-center space-y-16 py-10 px-6 relative z-10 pt-24 md:pt-32 pb-20">
                    <div class="space-y-8 animate-fade-in-up">
                        <h2 class="text-4xl md:text-7xl font-black text-slate-900 leading-tight tracking-tight drop-shadow-sm">
                            画像の注釈を、<br class="md:hidden">
                            <span class="text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 via-purple-600 to-pink-600">もっと美しく。</span>
                        </h2>
                        <p class="text-slate-600 font-medium text-lg md:text-xl max-w-2xl mx-auto leading-relaxed">
                            インストール不要、ブラウザ完結のセキュアなエディタ。<br class="hidden md:block">
                            美しい矢印や枠線、モザイクを瞬時に追加して共有。
                        </p>
                    </div>

                    <div class="grid md:grid-cols-3 gap-8 text-left max-w-4xl mx-auto">
                        <div class="step-card animate-fade-in-up" style="animation-delay: 0.1s">
                            <div class="step-icon-wrapper"><i data-lucide="upload" class="w-6 h-6"></i></div>
                            <h3 class="font-bold text-xl mb-3 text-slate-800">1. Upload</h3>
                            <p class="text-sm text-slate-500 leading-relaxed font-medium">画像をドラッグ＆ドロップ。高画質のままブラウザで読み込みます。</p>
                        </div>
                        <div class="step-card animate-fade-in-up" style="animation-delay: 0.2s">
                            <div class="step-icon-wrapper"><i data-lucide="edit-3" class="w-6 h-6"></i></div>
                            <h3 class="font-bold text-xl mb-3 text-slate-800">2. Edit</h3>
                            <p class="text-sm text-slate-500 leading-relaxed font-medium">矢印で強調したり、プライバシー情報をモザイクで隠したり。</p>
                        </div>
                        <div class="step-card animate-fade-in-up" style="animation-delay: 0.3s">
                            <div class="step-icon-wrapper"><i data-lucide="download-cloud" class="w-6 h-6"></i></div>
                            <h3 class="font-bold text-xl mb-3 text-slate-800">3. Export</h3>
                            <p class="text-sm text-slate-500 leading-relaxed font-medium">画質を劣化させずに保存。ワンクリックで完了します。</p>
                        </div>
                    </div>

                    <div class="upload-area w-full max-w-2xl mx-auto p-16 flex flex-col items-center justify-center group animate-fade-in-up cursor-pointer" style="animation-delay: 0.4s" onclick="document.getElementById('fileInput').click()">
                        <div class="w-24 h-24 bg-indigo-50 rounded-full flex items-center justify-center mb-6 group-hover:scale-110 transition-transform shadow-inner">
                            <i data-lucide="image-plus" class="w-10 h-10 text-indigo-600"></i>
                        </div>
                        <h3 class="text-2xl font-bold text-slate-800 mb-2">画像ファイルをドロップ</h3>
                        <p class="text-slate-400 font-medium mb-8">またはクリックしてファイルを選択</p>
                        <button class="inline-flex items-center gap-2 text-sm font-bold text-white bg-slate-900 hover:bg-slate-800 px-8 py-4 rounded-full shadow-xl shadow-slate-900/20 transition-all active:scale-95">
                            画像を選択する
                        </button>
                    </div>
                </div>
            </div>

            <!-- キャンバスエリア -->
            <div id="dropZone" class="hidden flex-1 overflow-auto custom-scrollbar relative z-10 flex-col w-full h-full bg-[#f1f5f9]">
                <div class="absolute inset-0 z-0 opacity-[0.4]" style="background-image: radial-gradient(#9ca3af 1.5px, transparent 1.5px); background-size: 24px 24px;"></div>
                
                <div class="flex-grow flex items-center justify-center min-w-min min-h-min p-8 md:p-16 relative z-10">
                    <div id="canvasWrapper" class="relative shadow-2xl shadow-slate-900/10 rounded-xl overflow-hidden bg-white ring-1 ring-black/5">
                        <canvas id="c"></canvas>
                    </div>
                </div>
            </div>

            <!-- ズームコントロール -->
            <div id="zoomControls" class="hidden absolute bottom-8 left-1/2 -translate-x-1/2 items-center gap-1 bg-white/80 backdrop-blur-md shadow-float p-1.5 rounded-full border border-white/60 z-30 transition-all pb-[env(safe-area-inset-bottom)]">
                <button onclick="zoomOut()" class="w-10 h-10 rounded-full hover:bg-white flex items-center justify-center text-slate-600 transition-colors"><i data-lucide="minus" class="w-5 h-5"></i></button>
                <span id="zoomLevel" class="text-sm font-bold text-slate-800 w-14 text-center select-none tabular-nums">100%</span>
                <button onclick="zoomIn()" class="w-10 h-10 rounded-full hover:bg-white flex items-center justify-center text-slate-600 transition-colors"><i data-lucide="plus" class="w-5 h-5"></i></button>
                <div class="w-px h-5 bg-slate-300 mx-2"></div>
                <button onclick="fitToScreen()" class="px-5 py-2 rounded-full bg-slate-100 hover:bg-white text-xs font-bold text-slate-700 transition-colors uppercase tracking-wide">Fit</button>
            </div>

            <!-- サイズ設定パネル -->
            <div id="sizePickerPanel" class="hidden absolute glass-panel z-40 w-full md:w-72 md:rounded-3xl p-6 left-0 bottom-0 md:left-[112px] md:bottom-auto md:top-24 origin-bottom-left">
                <div class="w-12 h-1.5 bg-slate-300/50 rounded-full mx-auto mb-6 md:hidden"></div>
                <div class="text-xs font-bold text-slate-500 uppercase tracking-wider mb-2" id="size-label">Line Width</div>
                <div class="drum-container mb-5">
                    <div class="drum-mask"></div><div class="drum-highlight"></div>
                    <div class="drum-scroll no-scrollbar" id="drum-scroller"></div>
                </div>
                <div class="mb-5 px-1"><input type="range" min="1" max="100" value="4" id="sheet-slider" oninput="setSize(this.value)" class="w-full"></div>
                <div class="flex items-center justify-between pt-4 border-t border-slate-200" id="rounded-option">
                    <span class="text-sm font-bold text-slate-600">角丸 (Rounded)</span>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="rounded-toggle" class="sr-only peer" checked onchange="setRounded(this.checked)">
                        <div class="w-12 h-7 bg-slate-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-6 after:w-6 after:transition-all peer-checked:bg-brand-600 transition-colors shadow-inner"></div>
                    </label>
                </div>
                <button onclick="closeAllModals()" class="mt-6 w-full py-3.5 bg-slate-900 text-white rounded-2xl text-base font-bold md:hidden shadow-xl shadow-slate-900/10">完了</button>
            </div>

            <!-- 色設定パネル -->
            <div id="colorPickerPanel" class="hidden absolute glass-panel z-40 w-full md:w-72 md:rounded-3xl p-6 left-0 bottom-0 md:left-[112px] md:bottom-auto md:top-64 origin-bottom-left">
                <div class="w-12 h-1.5 bg-slate-300/50 rounded-full mx-auto mb-6 md:hidden"></div>
                <div class="text-xs font-bold text-slate-500 uppercase tracking-wider mb-4 text-center md:text-left">Color</div>
                <div class="grid grid-cols-5 gap-4 mb-6 place-items-center">
                    <button onclick="setColor('#ef4444')" class="w-10 h-10 rounded-full bg-red-500 hover:scale-110 transition-transform color-dot active shadow-sm"></button>
                    <button onclick="setColor('#2563eb')" class="w-10 h-10 rounded-full bg-blue-600 hover:scale-110 transition-transform color-dot shadow-sm"></button>
                    <button onclick="setColor('#10b981')" class="w-10 h-10 rounded-full bg-emerald-500 hover:scale-110 transition-transform color-dot shadow-sm"></button>
                    <button onclick="setColor('#f59e0b')" class="w-10 h-10 rounded-full bg-amber-500 hover:scale-110 transition-transform color-dot shadow-sm"></button>
                    <button onclick="setColor('#1e293b')" class="w-10 h-10 rounded-full bg-slate-800 hover:scale-110 transition-transform color-dot shadow-sm"></button>
                    <button onclick="setColor('#ffffff')" class="w-10 h-10 rounded-full bg-white border border-slate-200 hover:scale-110 transition-transform color-dot shadow-sm"></button>
                    <button onclick="setColor('#ec4899')" class="w-10 h-10 rounded-full bg-pink-500 hover:scale-110 transition-transform color-dot shadow-sm"></button>
                    <button onclick="activateEyeDropper()" class="w-10 h-10 rounded-full bg-slate-100 border border-slate-200 flex items-center justify-center text-slate-500 hover:bg-slate-200 transition-colors shadow-sm" title="スポイト"><i data-lucide="pipette" class="w-5 h-5"></i></button>
                </div>
                <div class="color-input-wrapper mb-2">
                    <input type="color" id="native-color-picker" oninput="setColor(this.value)">
                    <div class="absolute inset-0 flex items-center justify-center pointer-events-none text-xs font-bold text-slate-500 bg-slate-50/50 backdrop-blur-sm">Custom Color</div>
                </div>
                <button onclick="closeAllModals()" class="mt-6 w-full py-3.5 bg-slate-900 text-white rounded-2xl text-base font-bold md:hidden shadow-xl shadow-slate-900/10">完了</button>
            </div>

            <div id="modalOverlay" onclick="closeAllModals()" class="hidden absolute inset-0 bg-slate-900/20 backdrop-blur-[2px] z-30 transition-opacity"></div>
        </main>
    </div>

    <!-- トースト通知 -->
    <div id="toast">
        <div id="toast-icon-bg" class="bg-emerald-100 text-emerald-600 p-1 rounded-full"><i data-lucide="check" class="w-4 h-4 stroke-[3]"></i></div>
        <span id="toastMsg" class="text-sm font-bold text-white">保存しました</span>
    </div>

    <script>
        lucide.createIcons();
        const canvas = new fabric.Canvas('c', { selection: true, preserveObjectStacking: true, backgroundColor: '#ffffff', uniformScaling: false });
        fabric.Object.prototype.set({ transparentCorners: false, cornerColor: '#ffffff', cornerStrokeColor: '#2563eb', borderColor: '#2563eb', cornerSize: 12, padding: 8, cornerStyle: 'circle', borderDashArray: [4, 4], borderOpacityWhenMoving: 0.5, uniformScaling: false });
        
        let STATE = { color: '#ef4444', width: 4, fontSize: 32, mosaicSize: 8, rounded: true, maskColor: '#1e293b', mode: 'select', img: null, zoom: 1.0, scaleFactor: 1.0 };
        
        // ドラムロール生成
        const drumScroller = document.getElementById('drum-scroller');
        const SIZE_OPTIONS = [2, 4, 6, 8, 10, 12, 16, 20, 24, 32, 40, 48, 64, 80, 96, 128, 160];
        SIZE_OPTIONS.forEach(w => {
            const div = document.createElement('div'); div.className = 'drum-item'; div.textContent = w; div.dataset.value = w;
            div.onclick = () => { div.scrollIntoView({behavior: 'smooth', block: 'center'}); setSize(w); };
            drumScroller.appendChild(div);
        });
        
        let drumTimeout;
        drumScroller.addEventListener('scroll', () => {
            clearTimeout(drumTimeout);
            drumTimeout = setTimeout(() => {
                const cRect = drumScroller.getBoundingClientRect(); const cy = cRect.top + cRect.height/2;
                let closest = null, minDiff = Infinity;
                document.querySelectorAll('.drum-item').forEach(item => {
                    const rect = item.getBoundingClientRect();
                    const diff = Math.abs(cy - (rect.top + rect.height/2));
                    item.classList.remove('active');
                    if(diff < minDiff) { minDiff = diff; closest = item; }
                });
                if(closest) { closest.classList.add('active'); setSize(closest.dataset.value); }
            }, 50);
        });

        function toggleSizePicker() { togglePanel('sizePickerPanel'); updatePanelContent(); }
        function toggleColorPicker() { togglePanel('colorPickerPanel'); }
        function togglePanel(id) {
            const el = document.getElementById(id); const overlay = document.getElementById('modalOverlay');
            const isOpen = !el.classList.contains('hidden');
            closeAllModals();
            if(!isOpen) { el.classList.remove('hidden'); el.classList.add('panel-enter'); overlay.classList.remove('hidden'); }
        }
        function closeAllModals() {
            ['sizePickerPanel', 'colorPickerPanel'].forEach(pid => document.getElementById(pid).classList.add('hidden'));
            document.getElementById('modalOverlay').classList.add('hidden');
        }

        function updatePanelContent() {
            const obj = canvas.getActiveObject();
            const isText = STATE.mode === 'text' || (obj && obj.type === 'i-text');
            const isMosaic = STATE.mode === 'mask-mosaic' || (obj && obj.isMosaic);
            let label = 'Line Width'; if(isText) label = 'Text Size'; if(isMosaic) label = 'Mosaic Size';
            document.getElementById('size-label').textContent = label;
            document.getElementById('rounded-option').style.display = (isText||isMosaic) ? 'none' : 'flex';
            let val = STATE.width; if(isText) val = STATE.fontSize; if(isMosaic) val = STATE.mosaicSize;
            setTimeout(() => {
                const items = Array.from(document.querySelectorAll('.drum-item'));
                const target = items.reduce((p, c) => Math.abs(c.dataset.value - val) < Math.abs(p.dataset.value - val) ? c : p);
                if(target) target.scrollIntoView({block: 'center'});
            }, 50);
        }

        function setMode(m) {
            STATE.mode = m; document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById(`btn-${m}`); if(btn) btn.classList.add('active');
            canvas.isDrawingMode = false; canvas.selection = (m === 'select'); canvas.defaultCursor = m === 'select' ? 'default' : 'crosshair';
            canvas.getObjects().forEach(o => { o.selectable = (m === 'select'); o.evented = (m === 'select'); });
            canvas.requestRenderAll();
        }

        function setColor(val) {
            STATE.color = val; STATE.maskColor = val;
            document.getElementById('current-color-indicator').style.backgroundColor = val;
            document.getElementById('native-color-picker').value = val;
            document.querySelectorAll('.color-dot').forEach(el => el.classList.remove('active'));
            const obj = canvas.getActiveObject();
            if(obj) {
                if(obj.type==='i-text'||obj.type==='text') obj.set({fill: val});
                else if(obj.fill && obj.fill!=='transparent') obj.set({fill: val});
                else obj.set({stroke: val});
                canvas.requestRenderAll();
            }
        }
        function setSize(val) {
            const v = parseInt(val); const obj = canvas.getActiveObject();
            const isText = STATE.mode === 'text' || (obj && obj.type === 'i-text');
            const isMosaic = STATE.mode === 'mask-mosaic' || (obj && obj.isMosaic);
            document.getElementById('sheet-slider').value = v;
            if(isText) { STATE.fontSize = v; if(obj && obj.type==='i-text') { obj.set({fontSize: v * STATE.scaleFactor}); canvas.requestRenderAll(); } }
            else if(isMosaic) { STATE.mosaicSize = v; if(obj && obj.isMosaic) updateMosaic(obj); }
            else { STATE.width = v; if(obj && obj.stroke) { obj.set({strokeWidth: v * STATE.scaleFactor}); canvas.requestRenderAll(); } }
        }
        function setRounded(v) {
            STATE.rounded = v; const obj = canvas.getActiveObject();
            if(obj && obj.type==='rect' && obj.fill==='transparent') { const r = v ? 5 * STATE.scaleFactor : 0; obj.set({rx:r, ry:r}); canvas.requestRenderAll(); }
        }

        canvas.on('selection:created', syncState); canvas.on('selection:updated', syncState);
        function syncState(e) {
            const obj = e.selected[0]; if(!obj) return;
            const col = obj.stroke || obj.fill; if(col && col!=='transparent' && col.startsWith('#')) setColor(col);
            let val = STATE.width;
            if(obj.type === 'i-text') val = Math.round(obj.fontSize / STATE.scaleFactor);
            else if(obj.isMosaic && obj.filters && obj.filters[0]) val = Math.round(obj.filters[0].blocksize / STATE.scaleFactor);
            else if(obj.strokeWidth) val = Math.round(obj.strokeWidth / STATE.scaleFactor);
            setSize(val); if(!document.getElementById('sizePickerPanel').classList.contains('hidden')) updatePanelContent();
        }

        canvas.on('mouse:down', opt => {
            if(STATE.mode === 'select') return;
            const p = canvas.getPointer(opt.e);
            const sf = STATE.scaleFactor;
            const sw = STATE.width * sf;
            const sr = STATE.rounded ? 5 * sf : 0;
            const size = 100 * sf;
            
            if(STATE.mode === 'rect') addToCanvas(new fabric.Rect({ left: p.x, top: p.y, width: size, height: size*0.6, fill: 'transparent', stroke: STATE.color, strokeWidth: sw, rx: sr, ry: sr, strokeUniform: true }));
            else if(STATE.mode === 'arrow') { const hs = 10*sf + sw*0.5; addToCanvas(new fabric.Path(`M 0 0 L ${size} 0 M ${size-hs} -${hs} L ${size} 0 L ${size-hs} ${hs}`, { left: p.x, top: p.y, fill: 'transparent', stroke: STATE.color, strokeWidth: sw, strokeLineCap: 'round', strokeLineJoin: 'round' })); }
            else if(STATE.mode === 'text') { 
                const t = new fabric.IText('', { 
                    left: p.x, top: p.y, fontFamily: 'Noto Sans JP', fontSize: STATE.fontSize*sf, fill: STATE.color, fontWeight: 'bold' 
                }); 
                t.set({uniformScaling: true}); addToCanvas(t); t.bringToFront(); t.enterEditing(); if(t.hiddenTextarea) t.hiddenTextarea.focus();
            }
            else if(STATE.mode === 'mask-black') addToCanvas(new fabric.Rect({ left: p.x, top: p.y, width: size, height: size*0.4, fill: STATE.maskColor, rx: 0, ry: 0 }));
            else if(STATE.mode === 'mask-mosaic') addMosaic(p.x, p.y);
            setMode('select');
        });

        function addToCanvas(obj) {
            if(obj.type!=='i-text') obj.setControlsVisibility({mt:true, mb:true, ml:true, mr:true, bl:true, br:true, tl:true, tr:true, mtr:true});
            else obj.setControlsVisibility({mt:false, mb:false, ml:false, mr:false, bl:true, br:true, tl:true, tr:true, mtr:true});
            canvas.add(obj); 
            canvas.setActiveObject(obj);
            if(obj.type !== 'i-text') { canvas.getObjects().forEach(o => { if(o.type === 'i-text') o.bringToFront(); }); }
        }

        function addMosaic(x, y) {
            if(!STATE.img) return;
            const w = 120 * STATE.scaleFactor; const h = 60 * STATE.scaleFactor;
            fabric.Image.fromURL(cropOriginalImage(x, y, w, h), img => {
                img.set({left: x, top: y, width: w, height: h, isMosaic: true});
                img.filters.push(new fabric.Image.filters.Pixelate({blocksize: STATE.mosaicSize * STATE.scaleFactor}));
                img.applyFilters(); addToCanvas(img);
            });
        }
        canvas.on('object:modified', e => { if(e.target && e.target.isMosaic) updateMosaic(e.target); });
        function cropOriginalImage(l, t, w, h) {
            const c = document.createElement('canvas'); c.width = w; c.height = h;
            c.getContext('2d').drawImage(STATE.img.getElement(), l, t, w, h, 0, 0, w, h);
            return c.toDataURL();
        }
        function updateMosaic(obj) {
            const newImg = new Image();
            newImg.onload = () => {
                obj.setElement(newImg); obj.filters = [new fabric.Image.filters.Pixelate({blocksize: STATE.mosaicSize * STATE.scaleFactor})];
                obj.applyFilters(); obj.set({scaleX: 1, scaleY: 1}); canvas.requestRenderAll();
            };
            newImg.src = cropOriginalImage(obj.left, obj.top, obj.width * obj.scaleX, obj.height * obj.scaleY);
        }

        function deleteObject() {
            const actives = canvas.getActiveObjects();
            if(actives.length) { actives.forEach(o => canvas.remove(o)); canvas.discardActiveObject(); }
            else showToast('削除する要素がありません', true);
        }
        document.addEventListener('keydown', e => {
            if((e.key==='Delete'||e.key==='Backspace') && canvas.getActiveObject() && !canvas.getActiveObject().isEditing) deleteObject();
            if(e.ctrlKey || e.metaKey) {
                if(e.key==='='||e.key==='+') { e.preventDefault(); zoomIn(); }
                if(e.key==='-') { e.preventDefault(); zoomOut(); }
                if(e.key==='0') { e.preventDefault(); fitToScreen(); }
            }
        });
        document.getElementById('dropZone').addEventListener('wheel', e => {
            if(e.ctrlKey || e.metaKey) { e.preventDefault(); let z = STATE.zoom * (0.999 ** e.deltaY); if(z>5)z=5; if(z<0.1)z=0.1; setZoom(z); }
        }, {passive:false});
        document.getElementById('fileInput').addEventListener('change', handleFile);
        const dz = document.querySelector('.upload-area');
        if(dz) {
            dz.addEventListener('dragover', e => { e.preventDefault(); dz.classList.add('drag-over'); });
            dz.addEventListener('dragleave', e => { e.preventDefault(); dz.classList.remove('drag-over'); });
            dz.addEventListener('drop', e => { e.preventDefault(); dz.classList.remove('drag-over'); if(e.dataTransfer.files[0]) handleFile({target:{files:[e.dataTransfer.files[0]]}}); });
        }
        document.addEventListener('paste', e => {
            const items = e.clipboardData.items;
            for(let i=0; i<items.length; i++) if(items[i].type.indexOf('image')!==-1) loadBlob(items[i].getAsFile());
        });

        function handleFile(e) {
            const f = e.target.files[0]; if(!f) return;
            if(f.type.startsWith('image/')) loadBlob(f); else showToast('画像のみ対応しています', true);
            e.target.value = '';
        }
        function loadBlob(blob) {
            const r = new FileReader();
            r.onload = f => { const i = new Image(); i.src = f.target.result; i.onload = () => initEditor(i); };
            r.readAsDataURL(blob);
        }
        function showEmptyState() {
            document.getElementById('emptyState').classList.remove('hidden');
            
            const uiElements = ['dropZone', 'zoomControls', 'closeBtn', 'actionButtons', 'sidebar'];
            uiElements.forEach(id => {
                const el = document.getElementById(id);
                if(el) {
                    el.classList.add('hidden');
                    el.classList.remove('flex');
                }
            });
            
            closeAllModals();
        }

        function showEditorState() {
            document.getElementById('emptyState').classList.add('hidden');
            
            const uiElements = ['dropZone', 'zoomControls', 'closeBtn', 'actionButtons', 'sidebar'];
            uiElements.forEach(id => {
                const el = document.getElementById(id);
                if(el) {
                    el.classList.remove('hidden');
                    el.classList.add('flex');
                }
            });
        }

        function hardResetCanvas() {
            // Canvasクリア
            try {
                canvas.discardActiveObject();
                const objs = canvas.getObjects();
                if (objs && objs.length) {
                    // コピー配列を作って削除
                    [...objs].forEach(o => canvas.remove(o));
                }
                canvas.clear(); 
            } catch (e) { console.error(e); }

            // STATEリセット
            STATE = { 
                color: '#ef4444', 
                width: 4, 
                fontSize: 32, 
                mosaicSize: 8, 
                rounded: true, 
                maskColor: '#1e293b', 
                mode: 'select', 
                img: null, 
                zoom: 1.0, 
                scaleFactor: 1.0 
            };

            // Canvasリセット (安全なサイズへ)
            canvas.setZoom(1);
            canvas.setDimensions({ width: 800, height: 600 });
            canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas));

            // UIリセット
            const zoomLabel = document.getElementById('zoomLevel');
            if (zoomLabel) zoomLabel.textContent = '100%';
            
            const sizeSlider = document.getElementById('sheet-slider');
            if (sizeSlider) sizeSlider.value = '4';

            // ツールボタンリセット
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            const selBtn = document.getElementById('btn-select');
            if(selBtn) selBtn.classList.add('active');

            // ファイル入力リセット
            const fi = document.getElementById('fileInput');
            if (fi) fi.value = '';
        }

        function resetEditor() {
            hardResetCanvas();
            showEmptyState();
            showToast('最初の画面に戻りました');
        }

        function closeEditor() {
            resetEditor();
        }

        function initEditor(imgTag) {
            showEditorState();
            
            STATE.img = new fabric.Image(imgTag, { selectable: false, evented: false });
            const maxDim = Math.max(imgTag.width, imgTag.height);
            STATE.scaleFactor = Math.max(1, maxDim / 1200); 
            
            // 初期値セット
            setSize(6); 

            canvas.setDimensions({ width: imgTag.width, height: imgTag.height });
            canvas.setBackgroundImage(STATE.img, canvas.renderAll.bind(canvas));
            fitToScreen(); 
            setMode('select');
        }

        function fitToScreen() {
            if(!STATE.img) return;
            const c = document.getElementById('dropZone');
            const vw = c.clientWidth - 80; const vh = c.clientHeight - 80;
            if(vw<=0 || vh<=0) return;
            setZoom(Math.min(1, Math.min(vw/STATE.img.width, vh/STATE.img.height)));
        }
        function setZoom(z) {
            STATE.zoom = z; canvas.setZoom(z);
            canvas.setDimensions({ width: STATE.img.width * z, height: STATE.img.height * z });
            document.getElementById('zoomLevel').textContent = Math.round(z*100) + '%';
        }
        function zoomIn() { let z = STATE.zoom * 1.2; if(z>5)z=5; setZoom(z); }
        function zoomOut() { let z = STATE.zoom / 1.2; if(z<0.1)z=0.1; setZoom(z); }

        function saveImage() {
            if(!STATE.img) return;
            const z = STATE.zoom; setZoom(1); 
            canvas.discardActiveObject(); canvas.renderAll();
            canvas.getElement().toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const l = document.createElement('a'); l.download = `snapmark-${Date.now()}.png`; l.href = url;
                document.body.appendChild(l); l.click(); document.body.removeChild(l);
                showToast('保存しました');
                URL.revokeObjectURL(url);
                setZoom(z);
            }, 'image/png', 1.0);
        }
        
        function resetCanvas() { if(confirm('全消去しますか？')) canvas.getObjects().forEach(o => canvas.remove(o)); }

        let toastTimeout;
        function showToast(msg, isError = false) {
            const t = document.getElementById('toast');
            const iconBg = document.getElementById('toast-icon-bg');
            document.getElementById('toastMsg').textContent = msg;
            
            // Re-inject icon HTML
            const iconName = isError ? 'alert-circle' : 'check';
            const iconClass = isError ? "w-4 h-4 stroke-[3] text-rose-500" : "w-4 h-4 stroke-[3] text-emerald-600";
            iconBg.innerHTML = `<i data-lucide="${iconName}" class="${iconClass}"></i>`;
            
            t.className = "fixed top-24 left-1/2 -translate-x-1/2 bg-white/90 backdrop-blur pl-4 pr-6 py-3 rounded-full shadow-float flex items-center gap-3 z-50 border transition-all duration-300";
            
            if(isError) {
                iconBg.className = 'bg-rose-100 p-1 rounded-full'; t.classList.add('border-rose-200');
            } else {
                iconBg.className = 'bg-emerald-100 p-1 rounded-full'; t.classList.add('border-white/50');
            }
            lucide.createIcons();

            t.classList.remove('toast-hidden'); t.classList.add('show');

            if(toastTimeout) clearTimeout(toastTimeout);
            toastTimeout = setTimeout(() => {
                t.classList.remove('show'); t.classList.add('toast-hidden');
            }, 3000);
        }
        async function activateEyeDropper() {
            if (!window.EyeDropper) { showToast('スポイト未対応', true); return; }
            try { const r = await new EyeDropper().open(); setColor(r.sRGBHex); } catch(e){}
        }
    </script>
</body>
</html>
